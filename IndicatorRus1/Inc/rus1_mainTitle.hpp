
#ifndef __rus1_mainTitle__
#define __rus1_mainTitle__

/*
модуль для: 
  - инструкции.
  - указания режимов работы прибора.
*/

/*
///////////////////////////////////////////////////////////////////////////////
// Инструкция проекта "EngineRus1" (перев."ДвижокРус1", далее - проект)
///////////////////////////////////////////////////////////////////////////////

  Введение:
  Проект "EngineRus1" тестировался на микроконтроллере (далее - мк) MSP430G2553.
  Индикаторная плата РУС-1 (далее - РУС-1) представляет из себя символьный LCD-модуль с 4 кнопками, подключённых 
по одной к 4-битной шине данных LCD-модуля. Можно изготовить самому, схема подключения кнопок см. "scheme of buttons.JPG".
  РУС-1 производится ООО "НПО Наука" http:// nponauka.com.
  При разработке проекта, РУС-1 использовал LCD-модуль "AMPIRE AC-162A" (далее - LCD-дисплей, см. "AC-162A datasheet.pdf").
  Код в модулях rus1_*.* создан под 2-строчный дисплей (концепция при отображении переменной: первая строка - заголовок 
переменной, вторая строка - её значение; при отображении сообщения: первая строка - заголовок, вторая строка - "ОК"). 
  Из настроек lcd-экрана, свободно можно изменять максимальное количество столбцов дисплея.
    
  Цель проекта:
0. Облегчить разработку проектов, использующих РУС-1 (эффективная работа с деревом каталогов любой вложенности).
1. Предоставить исходный код для работы с индикаторной платой РУС-1, где с использованием прерывания от одного таймера 
  реализована работа с отсутствием "мёртвых" пауз по:
  - отправке команды или данных на LCD-дисплей.
  - реализации защиты от "дребезга" кнопок.
  - реализации защиты от "долгого" нажатия кнопки.
  Из сторонних модулей используется только msp430G2553.h / msp430G2452.h.
2. Демонстрация наглядной работы мк с индикаторной платой РУС-1 (опционально, см. rus1_mainTitle.h -> use_IndRUS1):
  - навигация по узлам treeNode [дерева наподобие TreeView в Delphi/С#] (см. модуль vl_TreeStructureGenerator_Structure.cpp).
  - "бегущие строки" (постепенный показ строк "слева-направо", если они не умещаются по ширине на экране LCD-дисплея).
  - редактирование данных с помощью кнопок РУС-1:
    * - изменение на геометрически изменяющееся значение (1, 10, 100, ...), порядок значения указывается 
      положением мигающего курсора. Положение курсора изменяется длительностью нажатия кнопок "вверх" и "вниз" 
      (см. rus1_stencil_funcs_changedata -> п/п Data_ChangeWithCursor).
    * изменение на фиксированное значение (см. rus1_stencil_funcs_changedata -> п/п Data_ChangeFixGetLnChange).
    * изменение по массиву чисел допустимых значений (см. rus1_stencil_funcs_changedata -> п/п Data_ChangeIndex_ArrayLong).
    * изменение по массиву строк допустимых значений (см. rus1_stencil_funcs_changedata -> п/п Data_ChangeIndex_ArrayStr).
  Примечание: при старте 
    включение зелёного светодиода означает, что выполнение п/п OnProgramStart [инициализация системы] прошла успешно.
    
  IDE:
  Проект "EngineRus1" разрабатывался в ПО IAR embedded workbench for msp430 версии 6.40.1 
лицензия 8K KickStart Edition (ограничение по размеру кода 8кб).
Настройка проекта: в IAR 6.40.1 всё выставлено по умолчанию.
Значения в IAR 6.40.1 основных пунктов настроек по умолчанию:
  1. General Options -> Stack/Heap - не указан.
  2. C/C++ Compiler -> Optimzaions - None.
  3. Linker -> Linker Configuration File - не указан.

  Приоритет в составлении проекта, при равных условиях, по убыванию:
  - стабильность.
  - лёгкость внедрения в другие проекты.
  - быстродействие.
  - компактность кода.
  - расширяемость.

  Состав аппаратной конфигурации (для тестирования):
  - Launchpad "MSP-EXP430G2".
  - LCD-дисплей типа АС-162AYJ или индикаторная плата РУС-1.
    
  Основные действия для внедрения проекта:
  - скопировать, с содержимым, папку Rus1.
  - включить в проект Rus1\rus1_mainTitle.h.
  - указать количество столбцов lcd-дисплея (модуль rus1_screenLCD_AC-162A.* ).
  - назначить линии порта для линий RS, E и Data дисплея (модуль example_Peripherals.h).
  - составить структуру дерева TreeNode (пример - в vl_TreeStructureGenerator_Structure) и указать его имя в модуле rus1_mainTitle.h.
  - написать подрограммы вывода дерева TreeNode (пример - vl_TreeStructureGenerator_Functions.cpp).    

  Проект "EngineRus1" распространяется по принципу "как есть". Никаких явных или 
подразумеваемых гарантий не предусмотрено. Вся ответственность за последствия 
использования этого продукта лежит исключительно на вас. Ни автор, ни его 
представители не несут никакой ответственности за потери данных, повреждения, 
упущенную прибыль или другие утраты, к которым привело правильное или 
неправильное использование этой программы.

////////////////     
// Примечания:
  
  I.   
    Названия идентификаторов.
  - псевдофункции начинаются с d [define], например dDelayPWEN.
  - указатели начинаются с p [point], например pFunctionShowInfo.
  - подпрограммы, события и методы начинаются с заглавной буквы, например OnProgramStart.
  - переменные, работать с которыми полагается только через псевдофункции, начинаются с f_ [[for]function], например f_commandsCount.
  - переменные и константы начинаются с маленькой буквы, например GetIndexShowGoString.
    
  II.  
    Файлы.
  - псевдо-bool располагаются в файлах *_def.cpp.
  - с переменными, начинающиеся с 'f_', следует работать только через псевдофункции.
  - псевдофункции начинаются с буквы d, располагаются в файлах *_def.cpp.
  - псевдофункции не проверяют значения аргументов на допустимые значения.
  - подпрограммы должны учитывать возможность недопустимых значений аргументов.
  - прототипы подпрограмм располагаются в файлах *.h.
  - типы данных и переменные располагаются в файлах *_types.cpp или (если не указан) *.cpp.
  - define-константы располагаются в *.h.
  - модули, которые под новый прибор "пишут с нуля", называются example_*.*.
  - модули, составленные на основе модулей, составленных программой TreeStructureGenerator, называются
    vl_TreeStructureGenerator_*.*.
  - главный рабочий модуль по работе с индикаторной платой РУС-1: rus1.cpp.
    
  III. 
    С помощью модулей vl_TreeStructureGenerator_*.* описан пример разработки дерева каталог/данные для прибора.
    Краткое описание файлов vl_TreeStructureGenerator_*.*:
  - vl_TreeStructureGenerator_Structure.h   - пример описания структуры дерева.
  - vl_TreeStructureGenerator_Functions.cpp - пример функций вывода информации для TreeNode дерева.
  - vl_TreeStructureGenerator_Functions.h   - .h-файл для vl_TreeStructureGenerator_Functions.cpp.

    Краткое описание файлов example_*.*:
  - example_options.cpp     - пример используемых настроек.
  - example_peripherals.*   - пример настройки периферии для работы с индикаторной платой РУС-1.
  - example_work.*          - модуль для выполнения других работ.
    
  IV.
    Структура дерева TreeNode.
    Имя каталога (кроме корневого) выводится в одной строке дисплея, при этом для отображения и изменения данных
  используется две строки (концепция при отображении переменной: первая строка - заголовок переменной, 
  вторая строка - её значение; при отображении сообщения: первая строка - заголовок, вторая строка - "ОК").
    Поэтому у последнего в ветке каталога обязательно есть хотя бы 1 дочерний полноэкранный TreeNode.

  Определение каталог/данные:
   - Данные  - TreeNode, использующий для своего отображения полный экран; не имеет дочерних пунктов веток.
     Возможно наличие нескольких таких TreeNode в одном каталоге.
   - Каталог - TreeNode, отображающий каталоги (по одной в строке, кроме root) или данные.
    
    Структура дерева каталог/данные, представленного в текущем проекте:

каталог
Root(0xE000)--->Символы дисплея------------------------->Все символы в странице дисплея------------------>Данные вывести все символы в странице дисплея
             |                                        |->Все русские символы----------------------------->Данные вывести все русские символы
             |->Настройка частоты процессора------------>Данные частота процессора
             |->Демонстрация других способов настроек--->Пауза между выключением и включением нагрузки--->Данные пауза между выключением и включением нагрузки
                                                      |->Сколько дней хранить историю-------------------->Данные сколько дней хранить историю
                                                      |->Посылать ли смс о пропадании питания------------>Данные посылать ли смс о пропадании питания
                                                      |->Сбросить все настройки-------------------------->Выполнение сброса всех настроек

  Пояснения по структуре дерева:
  1. В каталоге "Символы дисплея" представлена ветка, отображающая информацию без возможности её изменения
    (тест вывода символов на дисплей):
    - "Вывести все символы в странице дисплея":
      выводит постранично все символы, имеющиеся в странице дисплея.
    - "Вывести все русские символы":
      выводит в алфавитном порядке все русские символы и знак '"'.
  2. В каталоге "Настройка частоты процессора" демонстрируется изменение частота процессора.
  3. В каталоге "Демонстрация других способов настроек" представлена ветка, демонстрирующая различные способы изменения данных: 
    - "Пауза между отключ и включ нагрузки":
      изменение на геометрически изменяющееся значение (1, 10, 100, ...), порядок значения указывается 
      положением мигающего курсора. Положение курсора изменяется длительностью нажатия кнопок "вверх" и "вниз" 
      (см. rus1_stencil_funcs_changedata.cpp -> Data_ChangeWithCursor).
    - "Сколько дней хранить историю":
      изменение на фиксированное значение (см. rus1_stencil_funcs_changedata.cpp -> Data_ChangeFixGetLnChange).
    - "Скорость связи с GSM-модемом":
      изменение по массиву чисел допустимых значений (см. rus1_stencil_funcs_changedata.cpp -> Data_ChangeIndex_ArrayLong).
    - "Посылать ли смс о пропадании питания":
      изменение по массиву строк допустимых значений (см. rus1_stencil_funcs_changedata.cpp -> Data_ChangeIndex_ArrayStr).
    - "Сбросить все настройки":
      демонстрация гибкости для решения нестандартных задач: без "захода в данные", используем "сторонние" флаги, 
      ставим dSetSpecRezhim, и вручную выходим обратно в TreeNode  (см. vl_TreeStructureGenerator_Functions.cpp -> DataResetAll)..
  4. Программный код для применения изменённых переменных, приведённых в п.3, отсутствует.
      
  V. Ориентирование при навигации в дереве:
    - в каталоге обязательно присутствие символа '>' или [если имеет только данные] 'закрашенная стрелка со стенкой' 
      в начале строки активного каталога.
    - в данных в первой строке присутствует заглавие [отображаемой информации]. Во второй строке - значение, при этом, 
    если возможно её редактирование, присутствует символ "Ввод" в конце строки (перед редактированием).

  VI.
    Нажатие кнопок на индикаторной плате РУС-1 (LCD-панель + 4 кнопки) используется для:
  - навигации по дереву.
  - изменения переменной (см. vlTree.f_rezhimSpecMessage).

  VII.
  Описание работы "КНОПКА" -> "Rrp_0 - rrp_5":
Изменение переменной производится в подпрограмме, прикреплённой к каждому узлу дерева currentTreeNode->pFunctionShowInfo().
Чтобы подпрограмма "знала", какие действия ей надо делать с изменяемой переменной при очередном её вызове, 
используется флаг, см. GetRRP.
Действия, которые надо делать подпрограмме при изменении переменной:
- только вошли в режим редактирования и пока ничего не указано, что делать с переменной (GetRRP == 1).
- "увеличивать" переменную (GetRRP == 2).
- "уменьшать" переменную (GetRRP == 3).
- завершить редактирование переменной, когда редактирование принято (GetRRP == 4).
- завершить редактирование переменной, когда редактирование отменено (GetRRP == 5).
При выводе значения переменной следует учитывать, что в конце строки (перед началом редактированием) присутствует символ "Ввод".

  VIII.
    "Режим спецсообщения" используется для показа пользователю срочного сообщения [об ошибке].
  См. rus1.cpp -> RezhimSpecMessage_On. 
  Режим спецсообщения сбрасывается при нажатии любой кнопки.
  Программист должен учесть, чтобы при редактировании переменной включением режима спецсообщения не мешалось сообщение.
    
  IX.  
    При демонстрации проекта, размер занимаемой памяти скомпилированным кодом после linking.
  Размер может меняться в зависимости от настроек ПО IAR embedded workbench for msp430 и его версии.
  1. В максимальном варианте (при включении флагов use_IndRUS1, use_GoString, use_WatchDog_for_PUC
и при динамически изменяемой f_cpuFreqMHz) с использованием всех возможных функций изменения переменной (см.п. IV.2):
    7.0 Kbytes of CODE  memory 
    235 bytes of DATA  memory
    975 bytes of CONST memory
  2. В минимальном варианте (не используя флагов, приведённых в п.1, и используя постоянную частоту ЦПУ):
    1.7 Kbytes of CODE  memory 
    165 bytes of DATA  memory
    334 bytes of CONST memory 
*/




////////////// 
// general
////////////// 

// чтоб не включать #include <locale.h>, когда он не включён
#ifndef _YVALS
  #define NULL 0
#endif




///////////////////////
// режимы работы прибора
///////////////////////


// Тестируем ли прибор.
// Влияет на:
//  1. Текст при старте.
// Примечание: testRus1 введён для вывода [при тесте] сообщений, которые прибор не должен выводить при обычной работе (это 
//             в приведённом "как есть" тестовом варианте не используется).
// #define testRus1

// Используем ли кнопки.
// Если не определён, то:
//  1. Индикаторная плата РУС-1 работает как обычная LCD-панель без кнопок.
//  2. Отсутствует дерево TreeNode.
#define use_IndRUS1

// используем ли shift-кнопки 
// кнопки, нажатие которых фиксируется во время их отжатия // позволяет делать сочетание кнопок
// имеет значенпие, только если используется use_IndRUS1
// #define useShiftButtons

// Используем ли бегущую строку.
// Не рекомендуется использовать на "медленном" дисплее.
// см. -> rus1.cpp -> LCD_ShowGoString.
#define use_GoString

// используем ли сторожевой таймер, для генерации сигнала сброса PUC.
//#define use_WatchDog_for_PUC

#endif // #ifndef __rus1_mainTitle__